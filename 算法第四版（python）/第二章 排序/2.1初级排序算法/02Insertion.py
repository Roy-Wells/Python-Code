"""
P157.插入排序算法
    基本思想：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
    步骤：
        从第一个元素开始，该元素可以认为已经被排序
        取出下一个元素，在已经排序的元素序列中从后向前扫描
        如果该元素（已排序）大于新元素，将该元素移到下一位置
        重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
        将新元素插入到该位置后重复步骤2~5
        6 5 3 1 7 8
        5 6 3 1 7 8
        5 3 6 1 7 8
        3 5 6 1 7 8
        3 5 1 6 7 8
        3 1 5 6 7 8
        1 3 5 6 7 8
    时间复杂度：O(n^2)
    空间复杂度：O(1)
    量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择

    为什么说平均情况下，插入排序比选择排序快?
        选择的逻辑是“每次在数组中找最小（大）的放到另一个数组的最后一个”，这样无论数组是什么样子的都要遍历需要排列的数组直到只有最后一个，
        所以，第一个数字要遍历n遍，第二个n-1……一直到1.
        选择排序固定需要n*(n-1)/2次比较
        插入排序法是类似我们打扑克时候理牌，拿到第一张，放在手里，第二张比较一下，是否大于第一张，大于就放在第一张的后面，
        这样第三张可能在扫描到第一张的时候就知道自己的位置，或者第二张，以此类推，第n张可能比较第一张牌，然后直接插到第一张前面，
        也可能比较到最后一张，插到最后面。
        插入排序需要n*(n-1)/4次比较
"""
def Insertion(array):
    l = len(array)
    #第一个元素认为已经被排序，因此index到1开始
    for i in range(1,l):
        #由后向前扫描，-1为由后向前，步长为1
        for j in range(i,0,-1):
            if(array[j]<array[j-1]):
                array[j],array[j-1]=array[j-1],array[j]
            else:
                break
    return array

if __name__ == '__main__':
    print(Insertion([32,12,234,45,23,67,23,12]))


